namespace MetaDslx.Soal;
generator XsdGenerator for object;

properties Properties
	bool ImportXsd = true;
end properties

template Generate(Namespace ns)
<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="[ns.Uri]"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xmlns:[ns.Prefix]="[ns.Uri]"
	[if (Properties.ImportXsd)]
		[loop(ins:ns.GetImportedNamespaces())]
		xmlns:[ins.Prefix]="[ins.Uri]"
		[end loop]
	[end if]
		elementFormDefault="qualified">
	[if (Properties.ImportXsd)]
		[loop(ins:ns.GetImportedNamespaces())]
	<xs:import namespace="[ins.Uri]" schemaLocation="[ins.FullName].xsd"/>
		[end loop]
	[end if]
	[loop(arr:ns.GetArrayTypes())]
^
	<xs:element name="[arr.GetXsdName()]" type="[ns.Prefix]:[arr.GetXsdName()]"/>
	<xs:complexType name="[arr.GetXsdName()]">
		<xs:sequence>
			<xs:element name="[arr.InnerType.GetXsdName()]" type="[arr.InnerType.GetNamespace(ns).Prefix]:[arr.InnerType.GetXsdName()]" nillable="[arr.InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	[end loop]
	[loop(ns.Declarations->etype:typeof(Enum))]
^
	<xs:element name="[etype.GetXsdName()]" type="[ns.Prefix]:[etype.GetXsdName()]"/>
	<xs:simpleType name="[etype.GetXsdName()]">
		<xs:restriction base="xs:string">
			[loop(etype->elit:EnumLiterals)]
			<xs:enumeration value="[elit.Name]"/>
			[end loop]
		</xs:restriction>
	</xs:simpleType>
	[end loop]
	[loop(ns.Declarations->stype:typeof(StructuredType))]
^
	<xs:element name="[stype.GetXsdName()]" type="[ns.Prefix]:[stype.GetXsdName()]"/>
	<xs:complexType name="[stype.GetXsdName()]">
		[switch(stype)]
		[type as Struct:]
			[if (stype.BaseType != null)]
		<xs:complexContent>
			<xs:extension base="[stype.BaseType.GetNamespace(ns).Prefix]:[stype.BaseType.GetXsdName()]">
				[GenerateStructuredTypeBody(ns, stype)]
			</xs:extension>
		</xs:complexContent>
			[else]
		[GenerateStructuredTypeBody(ns, stype)]
			[end if]
		[type as Exception:]
			[if (stype.BaseType != null)]
		<xs:complexContent>
			<xs:extension base="[stype.BaseType.GetNamespace(ns).Prefix]:[stype.BaseType.GetXsdName()]">
				[GenerateStructuredTypeBody(ns, stype)]
			</xs:extension>
		</xs:complexContent>
			[else]
		[GenerateStructuredTypeBody(ns, stype)]
			[end if]
		[type as Entity:]
			[if (stype.BaseType != null)]
		<xs:complexContent>
			<xs:extension base="[stype.BaseType.GetNamespace(ns).Prefix]:[stype.BaseType.GetXsdName()]">
				[GenerateStructuredTypeBody(ns, stype)]
			</xs:extension>
		</xs:complexContent>
			[else]
		[GenerateStructuredTypeBody(ns, stype)]
			[end if]
		[default:]
		[GenerateStructuredTypeBody(ns, stype)]
		[end switch]
	</xs:complexType>
	[end loop]
	[loop(ns.Declarations->intf:typeof(Interface)->op:Operations)]
		[if (!intf.HasAnnotation(SoalAnnotations.Rpc))]
		[if (intf.HasAnnotation(SoalAnnotations.NoWrap))]
			[loop(op->param:Parameters)]
	[GenerateElement(ns, op.Name + param.Name.ToPascalCase(), param.Type, param.Annotations)]
			[end loop]
			[if (op.ReturnType != SoalInstance.Void)]
	[GenerateElement(ns, op.Name+"Response", op.ReturnType, op.ReturnAnnotations)]
			[end if]
		[else]
^
	<xs:element name="[op.Name]" type="[ns.Prefix]:[op.Name]"/>
	<xs:complexType name="[op.Name]">
		<xs:sequence>
			[loop(op->param:Parameters where !param.HasAnnotation(SoalAnnotations.Attribute))]
			[GenerateElement(ns, param.Name, param.Type, param.Annotations)]
			[end loop]
		</xs:sequence>
		[loop(op->param:Parameters where param.HasAnnotation(SoalAnnotations.Attribute))]
		[GenerateElement(ns, param.Name, param.Type, param.Annotations)]
		[end loop]
	</xs:complexType>
		[if (!op.IsOneway)]
^
	<xs:element name="[op.Name]Response" type="[ns.Prefix]:[op.Name]Response"/>
	<xs:complexType name="[op.Name]Response">
			[if (op.ReturnType == SoalInstance.Void || op.ReturnAnnotations.ContainsAnnotation(SoalAnnotations.Attribute))]
		<xs:sequence/>
			[else]
		<xs:sequence>
			[GenerateElement(ns, op.Name+"Result", op.ReturnType, op.ReturnAnnotations)]
		</xs:sequence>
			[end if]
		[if (op.ReturnAnnotations.ContainsAnnotation(SoalAnnotations.Attribute))]
		[GenerateElement(ns, op.Name+"Result", op.ReturnType, op.ReturnAnnotations)]
		[end if]
	</xs:complexType>
		[end if]
		[end if]
		[end if]
	[end loop]
</xs:schema>
end template

template GenerateStructuredTypeBody(Namespace ns, StructuredType stype)
<xs:[GetStructKind(stype)]>
	[loop(stype->prop:Properties where !prop.HasAnnotation(SoalAnnotations.Attribute))]
	[GenerateElement(ns, prop.Name, prop.Type, prop.Annotations)]
	[end loop]
</xs:[GetStructKind(stype)]>
[loop(stype->prop:Properties where prop.HasAnnotation(SoalAnnotations.Attribute))]
[GenerateElement(ns, prop.Name, prop.Type, prop.Annotations)]
[end loop]
end template

template GenerateElement(Namespace ns, string name, SoalType t, IList<Annotation> annots)
[if (annots.ContainsAnnotation(SoalAnnotations.Attribute))]
	[if ((t is ArrayType || (t is NonNullableType && ((NonNullableType)t).InnerType is ArrayType)) && annots.ContainsAnnotation(SoalAnnotations.NoWrap))]
		[if (t is ArrayType)]
<xs:attribute name="[name]" type="[((ArrayType)t).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)t).InnerType.GetXsdName()]"[GetAttributeRequired(annots)]/>
		[else]
<xs:attribute name="[name]" type="[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetXsdName()]"[GetAttributeRequired(annots)]/>
		[end if]
	[else]
<xs:attribute name="[name]" type="[t.GetNamespace(ns).Prefix]:[t.GetXsdName()]"[GetAttributeRequired(annots)]/>
	[end if]
[else]
	[if ((t is ArrayType || (t is NonNullableType && ((NonNullableType)t).InnerType is ArrayType)) && annots.ContainsAnnotation(SoalAnnotations.NoWrap))]
		[if (t is ArrayType)]
<xs:element name="[name]" type="[((ArrayType)t).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)t).InnerType.GetXsdName()]" nillable="[((ArrayType)t).InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		[else]
<xs:element name="[name]" type="[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetXsdName()]" nillable="[((ArrayType)((NonNullableType)t).InnerType).InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		[end if]
	[else]
<xs:element name="[name]" type="[t.GetNamespace(ns).Prefix]:[t.GetXsdName()]" nillable="[t.IsNullableXsd()]"[GetElementOptional(annots)]/>
	[end if]
[end if]
end template

function string GetStructKind(StructuredType st)
	if (st.HasAnnotation(SoalAnnotations.Choice))
		return "choice";
	else if (st.HasAnnotation(SoalAnnotations.All))
		return "all";
	else
		return "sequence";
	end if
end function

function string GetElementOptional(IList<Annotation> annots)
	if (!annots.ContainsAnnotation(SoalAnnotations.Attribute) && annots.ContainsAnnotation(SoalAnnotations.Optional)) 
		return " minOccurs=\"0\"";
	else
		return "";
	end if
end function

function string GetAttributeRequired(IList<Annotation> annots)
	if (annots.ContainsAnnotation(SoalAnnotations.Attribute) && annots.ContainsAnnotation(SoalAnnotations.Required)) 
		return " use=\"required\"";
	else
		return "";
	end if
end function
