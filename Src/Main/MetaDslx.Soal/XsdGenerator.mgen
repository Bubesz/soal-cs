namespace MetaDslx.Soal;
generator XsdGenerator for object;

properties Properties
	bool ImportXsd = true;
end properties

template Generate(Namespace ns)
<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="[ns.Uri]"
		xmlns:xs="http://www.w3.org/2001/XMLSchema"
		xmlns:[ns.Prefix]="[ns.Uri]"
	[if (Properties.ImportXsd)]
		[loop(ins:ns.GetImportedNamespaces())]
		xmlns:[ins.Prefix]="[ins.Uri]"
		[end loop]
	[end if]
		elementFormDefault="qualified">
	[if (Properties.ImportXsd)]
		[loop(ins:ns.GetImportedNamespaces())]
	<xs:import namespace="[ins.Uri]" schemaLocation="[ins.FullName].xsd"/>
		[end loop]
	[end if]
	[loop(arr:ns.GetArrayTypes())]
^
	<xs:element name="[arr.GetXsdName()]" type="[ns.Prefix]:[arr.GetXsdName()]"/>
	<xs:complexType name="[arr.GetXsdName()]">
		<xs:sequence>
			<xs:element name="[arr.InnerType.GetXsdName()]" type="[arr.InnerType.GetNamespace(ns).Prefix]:[arr.InnerType.GetXsdName()]" nillable="[arr.InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		</xs:sequence>
	</xs:complexType>
	[end loop]
	[loop(ns.Declarations->etype:typeof(Enum))]
^
	<xs:element name="[etype.GetXsdName()]" type="[ns.Prefix]:[etype.GetXsdName()]"/>
	<xs:simpleType name="[etype.GetXsdName()]">
		<xs:restriction base="xs:string">
			[loop(etype->elit:EnumLiterals)]
			<xs:enumeration value="[elit.Name]"/>
			[end loop]
		</xs:restriction>
	</xs:simpleType>
	[end loop]
	[loop(ns.Declarations->stype:typeof(StructuredType))]
^
	<xs:element name="[stype.GetXsdName()]" type="[ns.Prefix]:[stype.GetXsdName()]"/>
	<xs:complexType name="[stype.GetXsdName()]">
		<xs:[GetStructKind(stype)]>
			[loop(stype->prop:Properties)]
			[GenerateElement(ns, prop.Name, prop.Type, prop.Annotations)]
			[end loop]
		</xs:[GetStructKind(stype)]>
	</xs:complexType>
	[end loop]
	[loop(ns.Declarations->intf:typeof(Interface)->op:Operations)]
		[if (intf.HasAnnotation(SoalAnnotations.NoWrap))]
			[loop(op->param:Parameters)]
			[GenerateElement(ns, op.Name + param.Name.ToPascalCase(), param.Type, param.Annotations)]
			[end loop]
			[if (op.ReturnType != SoalInstance.Void)]
			[GenerateElement(ns, op.Name+"Response", op.ReturnType, op.ReturnAnnotations)]
			[end if]
		[else if (!intf.HasAnnotation(SoalAnnotations.Rpc))]
^
	<xs:element name="[op.Name]" type="[ns.Prefix]:[op.Name]"/>
	<xs:complexType name="[op.Name]">
		<xs:sequence>
			[loop(op->param:Parameters)]
			[GenerateElement(ns, param.Name, param.Type, param.Annotations)]
			[end loop]
		</xs:sequence>
	</xs:complexType>
		[if (!op.IsOneway)]
^
	<xs:element name="[op.Name]Response" type="[ns.Prefix]:[op.Name]Response"/>
	<xs:complexType name="[op.Name]Response">
			[if (op.ReturnType == SoalInstance.Void)]
		<xs:sequence/>
			[else]
		<xs:sequence>
			[GenerateElement(ns, op.Name+"Result", op.ReturnType, op.ReturnAnnotations)]
		</xs:sequence>
			[end if]
	</xs:complexType>
		[end if]
		[end if]
	[end loop]
</xs:schema>
end template

template GenerateElement(Namespace ns, string name, SoalType t, IList<Annotation> annots)
	[if ((t is ArrayType || (t is NonNullableType && ((NonNullableType)t).InnerType is ArrayType)) && annots.ContainsAnnotation(SoalAnnotations.NoWrap))]
		[if (t is ArrayType)]
<xs:element name="[name]" type="[((ArrayType)t).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)t).InnerType.GetXsdName()]" nillable="[((ArrayType)t).InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		[else]
<xs:element name="[name]" type="[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetNamespace(ns).Prefix]:[((ArrayType)((NonNullableType)t).InnerType).InnerType.GetXsdName()]" nillable="[((ArrayType)((NonNullableType)t).InnerType).InnerType.IsNullableXsd()]" minOccurs="0" maxOccurs="unbounded"/>
		[end if]
	[else]
<xs:element name="[name]" type="[t.GetNamespace(ns).Prefix]:[t.GetXsdName()]" nillable="[t.IsNullableXsd()]"/>
	[end if]
end template

function string GetStructKind(StructuredType st)
	if (st.HasAnnotation(SoalAnnotations.Choice))
		return "choice";
	else if (st.HasAnnotation(SoalAnnotations.All))
		return "all";
	else
		return "sequence";
	end if
end function
